import java.io.*;
import java.net.*;
import java.util.*;
import java.nio.*;
import java.util.BitSet;
import java.security.MessageDigest;

public class Peer extends Thread {

    /**
     * It has methods to perform handshake, alive, interested, and other
     * messages.
     */
    /**
     * Peer Information
     */
    public byte[] peerID;
    public String peerIP = null;
    public int peerPort = 0;
    public Socket peerSocket = null;
    public BitSet peerbitfield = null;
    /**
     * Connection Information
     */
    public DataOutputStream client2peer = null;
    public DataInputStream peer2client = null;
    /**
     * BOOLEAN Connection status
     */
    public boolean connected = false;
    public boolean handshakeConfirmed = false;
    public boolean[] booleanBitField = null;
    public boolean incoming = false;
    /**
     * BOOLEAN Peer Status
     */
    public boolean peerInterested;
    public boolean peerChoking;
    final static int KEY_CHOKE = 0;
    final static int KEY_UNCHOKE = 1;
    final static int KEY_INTERESTED = 2;
    final static int KEY_UNINTERESTED = 3;
    final static int KEY_HAVE = 4;
    final static int KEY_BITFIELD = 5;
    final static int KEY_REQUEST = 6;
    final static int KEY_PIECE = 7;
    final static int KEY_CANCEL = 8;
    final static int KEY_PORT = 9;
    
    /* ================================================================================ */
    /* 									Peer Constructor								*/
    /* ================================================================================ */
    public Peer(String IpNum, int peerPortNum, boolean incoming, String id) {
        if (!(id == null) && !(id.equals(""))) {
            this.peerID = id.getBytes();
        }
        this.peerIP = IpNum;
        this.peerPort = peerPortNum;
        this.booleanBitField = new boolean[RUBTClient.numPieces];
        this.incoming = incoming;
        start();
    }

    /* ================================================================================ */
    /* 										Methods										*/
    /* ================================================================================ */
    /**
     * METHOD: Create handshake
     */
    public static byte[] buildHandshake(String localPeerID, ByteBuffer infoHash) {
        /* Variables */
        int i = 0;
        byte[] handshakeBytes;

        /**
         * Create handshake byte array
         */
        handshakeBytes = new byte[68];

        /**
         * Begin byte array with byte "nineteen"
         */
        handshakeBytes[i] = 0x13; //decimal: 19
        i++;

        try {
            /**
             * Put "BitTorrent protocol"-byte array
             */
            byte[] btBytes = {'B', 'i', 't', 'T', 'o', 'r', 'r', 'e', 'n', 't',
                ' ', 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l'};
            System.arraycopy(btBytes, 0, handshakeBytes, i, btBytes.length);
            i = i + btBytes.length;

            /**
             * Put zero-byte array
             */
            byte[] zeroBytes = new byte[8];
            System.arraycopy(zeroBytes, 0, handshakeBytes, i, zeroBytes.length);
            i = i + zeroBytes.length;

            /**
             * Put 20-byte SHA-1 hash
             */
            System.arraycopy(infoHash.array(), 0, handshakeBytes, i, infoHash.array().length);
            i = i + infoHash.array().length;

            /**
             * Put peer id (generated by client)
             */
            System.arraycopy(localPeerID.getBytes("ASCII"), 0, handshakeBytes, i, localPeerID.getBytes("ASCII").length);
        } catch (UnsupportedEncodingException e) {
            System.err.println("ERROR: Could not complete handshake. ");
            e.printStackTrace();
        }
        return handshakeBytes;
    }

    /**
     * METHOD: Send handshake
     */
    public void sendHandshake(String localPeerID, ByteBuffer info_hash) {
        try {
            byte[] handshake = buildHandshake(localPeerID, info_hash);
            if (!connected) {
                this.setPeerConnection();
            }
            client2peer.write(handshake);
            client2peer.flush();
        } catch (IOException e) {
            System.err.println("Problem sending handshake to " + peerID);
            e.printStackTrace();
        }
    }

    /**
     * METHOD: Verify handshake
     */
    public boolean verifyHandshake(ByteBuffer torrentInfoHash) {
        /* Variables */
        int index = 0;
        byte[] trueInfoHash = torrentInfoHash.array();
        byte[] handshakeInfoHash = new byte[20];
        byte[] handshakeResponse = new byte[68];

        /**
         * Read response
         */
        try {
            peer2client.read(handshakeResponse);

			// Extract the peer id from the handshake response
            byte[] buffer = new byte[20];
            System.arraycopy(handshakeResponse, handshakeResponse.length - 21, buffer, 0, 20);
			this.setPeerID(buffer);

            /**
             * Extract info hash from handshake response
             */
            System.arraycopy(handshakeResponse, 28, handshakeInfoHash, 0, 20);

            /**
             * Verify if torrent info hash and handshake info hash are the
             * identical
             */
            while (index < 20) {
                if (handshakeInfoHash[index] != trueInfoHash[index]) {
                    peerSocket.close();
                    return false;
                } else {
                    ++index;
                }
            }
        } catch (Exception e) {
            System.err.println("Could not read handshakeResponse. ");

        }
        handshakeConfirmed = true;
        return true;
    }


    /**
     * Function will compute the SHA-1 hash of a piece and compare it to the
     * SHA-1 from the meta-info torrent file
     *
     * @param piece The byte array of the piece which was downloaded from the
     * peer
     * @param index The index number of the piece.
     * @return True if the piece matches the SHA-1 hash from the meta-info
     * torrent file otherwise false.
     */
    public boolean verifySHA(byte[] piece, int index) {
        MessageDigest digest = null;
        try {
            digest = MessageDigest.getInstance("SHA");
        } catch (Exception e) {
            System.out.println("Bad SHA algorithm");
            return false;
        }
        byte[] hash = digest.digest(piece);
        byte[] info_hash = RUBTClient.torrent.piece_hashes[index].array();
        for (int i = 0; i < hash.length; i++) {
            if (hash[i] != info_hash[i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * METHOD: Close peer socket
     */
    public void closePeerSocket() {
        try {
            if (peerSocket != null) {
                peerSocket.close();
            }
        } catch (Exception e) {
            System.err.println("ERROR: Could not close peer socket. ");
        }
    }

    /* currently not being used */
    public void terminateSocketConnections() {
        try {
            if (!peerSocket.isClosed()) {
                peerSocket.close();
                client2peer.close();
                peer2client.close();
            }
        } catch (Exception e) {
            System.err.println("ERROR: Could not terminate open socket connections. ");
        }
    }
    
    /**
     * Method: Running the program
     */
    public void run() {
        if (this.incoming) {

            setPeerConnection();
            sendHandshake(RUBTClient.peerID, RUBTClient.torrent.info_hash);
            sendBitfield(RUBTClient.Bitfield);
        }
        else {

            /* Set up connection with Peer */
            setPeerConnection();

            /* Establish handshake */
            sendHandshake(RUBTClient.peerID, RUBTClient.torrent.info_hash);
            System.out.println("Handshake sent");

            /* Receive and verify handshake */
            if (!verifyHandshake(RUBTClient.torrent.info_hash)) {
                System.err.println("ERROR: Unable to verify handshake. ");
            } else {
                int len = getPeerResponseInt();
                System.out.println(len);
                byte message = getPeerResponseByte();
                System.out.println(message);
                byte[] peerbits = getPeerResponse(len - 1);
                receiveBitfield(peerbits);
                System.out.println(peerbitfield.toString());
                Messages.interested(client2peer, peer2client);
                int numBlks = RUBTClient.numBlkPieceRatio;
                System.out.println("Original # of blocks " + numBlks);
                int total = 0;
                for (int i = 0; i < RUBTClient.numPieces; i++) {
                    if (!DownloadManager.hasPiece(i, this) && peerbitfield.get(i)) {
                        ByteArrayOutputStream currentPiece = new ByteArrayOutputStream();
                        System.out.println("Request Piece " + i);
                        if (i == RUBTClient.numPieces - 1) {
                            numBlks = (int) Math.ceil((double) RUBTClient.lastPieceSize / (double) RUBTClient.blockLength);
                            System.out.println("Blocks for last piece " + numBlks);
                        }
                        for (int j = 0; j < numBlks; j++) {
                            System.out.println("Request Block " + j);
                            if (j == numBlks - 1) {
                                if (i == RUBTClient.numPieces - 1) {
                                    Messages.request(i, j * RUBTClient.blockLength, RUBTClient.lastBlkSize, client2peer);
                                } else {
                                    Messages.request(i, j * RUBTClient.blockLength, RUBTClient.torrent.piece_length - (j * RUBTClient.blockLength), client2peer);
                                }
                            } else {
                                Messages.request(i, j * RUBTClient.blockLength, RUBTClient.blockLength, client2peer);
                            }
                            int length = getPeerResponseInt();
                            byte[] block = new byte[length - 9];
                            System.arraycopy(getPeerResponse(length), 9, block, 0, length - 9);
                            total += block.length;

                            try {
                                currentPiece.write(block);
                            } catch (IOException e) {
                                System.err.println("Error: Problem saving block " + j + " of piece " + i);
                            }
                            System.out.println(total + "/" + RUBTClient.torrent.file_length);
                        }
                        if (verifySHA(currentPiece.toByteArray(), i)) {
                            DownloadManager.savePiece(currentPiece, i, this);
                        }
                    }
                }
            }
        }
    }
        /* ================================================================================ */
        /* 										Messages 									*/
        /* ================================================================================ */

    public void receiveBitfield(byte[] response) {
        peerbitfield = new BitSet();
        int index = 0;
        for (byte b : response) {
            int h = (int) b;
            for (int j = 7; j >= 0; j--, index++) {
                int shifted = h >> j;
                peerbitfield.set(index, ((shifted & 1) == 1));
            }
        }
    }

    public synchronized boolean sendBitfield(BitSet bitfield) {
        try {
            byte[] bitfield_bytes = new byte[(bitfield.length() - 1) / 8 + 1];

            //Initialize to zero
            for (int x = 0; x < bitfield_bytes.length; x++) {
                bitfield_bytes[x] = (byte) 0;
            }

            //Converts Bitset to byte array
            for (int i = 0; i < bitfield.length(); i++) {
                if (bitfield.get(i)) {
                    bitfield_bytes[i / 8] |= 1 << (7 - (i % 8));
                }
            }

            ByteBuffer bitfield_buffer = ByteBuffer.allocate(5 + bitfield_bytes.length);
            bitfield_buffer.putInt(1 + bitfield_bytes.length);
            bitfield_buffer.put((byte) 5);
            bitfield_buffer.put(bitfield_bytes);
            client2peer.write(bitfield_buffer.array());
            client2peer.flush();
            System.out.println("Bitfield message sent");
            return true;
        } catch (Exception ioe) {
            System.err.println(ioe.getMessage());
            System.out.println("COULD NOT SEND BITFIELD MESSAGE");
            return false;
        }
    }


    /* ================================================================================ */
    /* 									Set Methods										*/
    /* ================================================================================ */
    /**
     * METHOD: Create socket for peer with given IP and Port
     */
    public void setPeerConnection() {
        try {
            /**
             * Create socket
             */
            this.peerSocket = new Socket(this.peerIP, this.peerPort);
            if (peerSocket != null) {
                /**
                 * store from peer to client
                 */
                this.peer2client = new DataInputStream(this.peerSocket.getInputStream());

                /**
                 * store from client to peer
                 */
                this.client2peer = new DataOutputStream(this.peerSocket.getOutputStream());
                connected = true;
            } else {
                connected = false;
            }
        } catch (Exception e) {
            System.err.println("ERROR: Could not create socket connection with IP: " + peerIP + " and Port: " + peerPort);
        }
    }

    /**
     * METHOD: Sets this peers ID to the given value
     *
     * @param
     */
    public void setPeerID(byte[] newID) {
        peerID = newID;
    }

    /* ================================================================================ */
    /* 									Get Methods										*/
    /* ================================================================================ */
    public byte[] getPeerID() {
        return peerID;
    }

    public String getPeerIP() {
        return peerIP;
    }

    public int getPeerPort() {
        return peerPort;
    }

    /**
     * Method: get complete peer response
     */
    public byte[] getPeerResponse(int length) {
        try {
            byte[] peerResponse = new byte[length];
            peer2client.readFully(peerResponse);

            return peerResponse;
        } catch (IOException e) {
            terminateSocketConnections();
            System.err.println("ERROR: Unable to receive peer response. ");
            return null;
        } catch (Exception e) {
            System.err.println("ERROR: Unable to receive peer response. ");
            return null;
        }
    }

    /**
     * Method: get byte response
     */
    public synchronized byte getPeerResponseByte() {
        try {
            return peer2client.readByte();
        } catch (IOException e) {
            terminateSocketConnections();
            System.err.println("ERROR: Unable to receive peer response. ");
            return -1;
        } catch (Exception e) {
            System.err.println("ERROR: Unable to receive peer response. ");
            return -1;
        }
    }

    /**
     * Method: get int response
     */
    public synchronized int getPeerResponseInt() {
        try {
            return peer2client.readInt();
        } catch (IOException e) {
            terminateSocketConnections();
            System.out.println("first " + e.toString());
            System.err.println("ERROR: Unable to receive peer response. ");
            return -1;
        } catch (Exception e) {
            System.out.println("second " + e.toString());
            System.err.println("ERROR: Unable to receive peer response. ");
            return -1;
        }
    }

    /* ================================================================================ */
    /* 									Is Methods										*/
    /* ================================================================================ */
    public boolean isPeerConnected() {
        return connected;
    }
}
